<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Códigos | Martial Spirit</title>

  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css" />
</head>

<body>
  <!-- HEADER -->
  <header>
    <div class="logo">
      <a href="index.html"><img src="img/logo2.png" alt="Logo Martial Spirit" /></a>
    </div>
    <nav>
      <ul>
        <li><a href="index.html">Início</a></li>
        <li><a href="sobre.html">Sobre</a></li>
        <li><a href="narrativa.html">Narrativa</a></li>
        <li><a href="modelos.html">Modelos 3D</a></li>
        <li><a href="codigo.html" class="active">Código</a></li>
        <li><a href="contato.html">Equipe</a></li>
      </ul>
    </nav>
  </header>

  <!-- SEÇÃO DE CÓDIGOS -->
  <section class="codigo-section">
    <div class="codigo-overlay"></div>

    <div class="codigo-content">
      <h1>Códigos do Projeto</h1>

      <div class="tabs">
        <div class="tab active" data-tab="codigo1">EnemyController.cs</div>
        <div class="tab" data-tab="codigo2">FighterController.cs</div>
        <div class="tab" data-tab="codigo3">Alvobalanca.cs</div>
      </div>

      <div class="editor-box">
        <div id="codigo1" class="codigo-bloco active">
          <pre><code class="language-csharp">
using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class EnemyController : MonoBehaviour
{
    [Header("Referências")]
    public Transform alvo;
    public FighterController playerController;

    [Header("Status")]
    public float vidaMax = 100f;
    private float vidaAtual;
    public Slider barraVida;
    public float estaminaMax = 100f;
    private float estaminaAtual;
    public Slider barraEstamina;

    [Header("Movimento")]
    public float velocidade = 3f;
    public float distanciaAtaque = 2f;

    [Header("Animator")]
    public Animator animator;
    public string parametroCorrendo = "Correndo";
    public string parametroAtaque = "Ataque";
    public string parametroMorte = "Morte";
    public string parametroIdle = "Idle";

    [Header("Ataque")]
    public float danoAtaque = 10f;
    public GameObject efeitoImpactoPrefab;

    [Header("Controle Luta")]
    public bool lutaIniciada = false;

    private bool atacando = false;
    private bool morto = false;

    void Start()
    {
        vidaAtual = vidaMax;
        estaminaAtual = estaminaMax;
        AtualizarBarras();
    }

    void Update()
    {
        if (!lutaIniciada || morto || atacando) return;
        if (alvo == null || playerController == null) return;

        float distancia = Vector3.Distance(transform.position, alvo.position);

        // Se estamina estiver baixa, recuar e recuperar
        if (estaminaAtual < 20f)
        {
            Vector3 direcaoRecuo = (transform.position - alvo.position).normalized;
            transform.position += direcaoRecuo * velocidade * Time.deltaTime;
            if (animator != null)
                animator.SetBool(parametroCorrendo, true);

            estaminaAtual += 15f * Time.deltaTime;
            if (estaminaAtual > estaminaMax) estaminaAtual = estaminaMax;
            AtualizarBarras();
            return;
        }

        // Se longe, correr atrás
        if (distancia > distanciaAtaque)
        {
            MoverAtrasDoPlayer();
        }
        else
        {
            StartCoroutine(ExecutarAtaque());
        }
    }

    void MoverAtrasDoPlayer()
    {
        Vector3 direcao = (alvo.position - transform.position).normalized;
        transform.position += direcao * velocidade * Time.deltaTime;

        transform.LookAt(new Vector3(alvo.position.x, transform.position.y, alvo.position.z));

        if (animator != null)
            animator.SetBool(parametroCorrendo, true);

        estaminaAtual += 10f * Time.deltaTime;
        if (estaminaAtual > estaminaMax) estaminaAtual = estaminaMax;
        AtualizarBarras();
    }

    IEnumerator ExecutarAtaque()
    {
        if (estaminaAtual < 20f) yield break;

        atacando = true;

        if (animator != null)
        {
            animator.SetBool(parametroCorrendo, false);
            animator.SetBool(parametroAtaque, true);
        }

        yield return new WaitForSeconds(0.5f);

        if (playerController != null)
            playerController.ReceberDano(danoAtaque, efeitoImpactoPrefab);

        estaminaAtual -= 20f;
        AtualizarBarras();

        if (animator != null)
            animator.SetBool(parametroAtaque, false);

        yield return new WaitForSeconds(0.8f);
        atacando = false;
    }

    public void ReceberDano(float dano, GameObject efeitoImpacto = null)
    {
        if (morto) return;

        vidaAtual -= dano;
        if (vidaAtual <= 0)
        {
            vidaAtual = 0;
            Morrer();
        }

        if (efeitoImpacto != null)
            Instantiate(efeitoImpacto, transform.position + Vector3.up * 1f, Quaternion.identity);

        StartCoroutine(ImpactShake());
        AtualizarBarras();
    }

    void Morrer()
    {
        morto = true;
        if (animator != null)
        {
            animator.SetBool(parametroCorrendo, false);
            animator.SetBool(parametroAtaque, false);
            animator.SetTrigger(parametroMorte);
        }
        Debug.Log("Inimigo derrotado!");
    }

    IEnumerator ImpactShake()
    {
        Vector3 posOriginal = transform.position;
        float shakeTempo = 0.2f;
        float shakeForca = 0.1f;
        float timer = 0f;

        while (timer < shakeTempo)
        {
            transform.position = posOriginal + (Vector3)Random.insideUnitCircle * shakeForca;
            timer += Time.deltaTime;
            yield return null;
        }

        transform.position = posOriginal;
    }

    void AtualizarBarras()
    {
        if (barraVida != null)
            barraVida.value = vidaAtual / vidaMax;
        if (barraEstamina != null)
            barraEstamina.value = estaminaAtual / estaminaMax;
    }
}
          </code></pre>
          <div class="codigo-resumo">
            <h3>Resumo:</h3>
            <p>Controla o comportamento do inimigo, incluindo perseguição, ataques, consumo e regeneração de estamina, recebimento de dano e morte. Também atualiza as barras de vida e estamina dinamicamente.</p>
          </div>
        </div>

        <div id="codigo2" class="codigo-bloco">
          <pre><code class="language-csharp">
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using System.Collections;

public class FighterController : MonoBehaviour
{
    [Header("Barras")]
    public Slider barraVida;
    public Slider barraEstamina;
    public float vidaMax = 100f;
    public float estaminaMax = 100f;

    [Header("Animator")]
    public Animator animator;
    public string parametroIdle = "Idle";
    public string parametroOiZuki = "OiZuki";
    public string parametroMaeGeri = "MaeGeri";
    public string parametroMawashiGeri = "MawashiGeri";
    public string parametroGedanBarai = "GedanBarai";
    public string parametroJodanUke = "JodanUke";
    public string parametroDefesa = "Defesa";

    [Header("Golpes")]
    public float danoOiZuki = 10f;
    public float danoMaeGeri = 15f;
    public float danoMawashiGeri = 20f;
    public float danoGedanBarai = 0f;
    public float danoJodanUke = 0f;

    [Header("Teclas")]
    public KeyCode teclaOiZuki = KeyCode.J;
    public KeyCode teclaMaeGeri = KeyCode.K;
    public KeyCode teclaMawashiGeri = KeyCode.U;
    public KeyCode teclaGedanBarai = KeyCode.L;
    public KeyCode teclaJodanUke = KeyCode.S;

    [Header("Referencia do Inimigo")]
    public EnemyController inimigo;

    [Header("Efeitos")]
    public GameObject efeitoGolpePrefab;
    public GameObject efeitoImpactoPrefab;
    public GameObject efeitoTrilhaGolpe;

    [Header("Dialogo")]
    public DialogoSimples dialogoSimples;
    public Sprite spriteSensei;
    public Sprite spriteJuiz;

    private float vidaAtual;
    private float estaminaAtual;
    private bool golpeExecutando = false;
    private bool defendendo = false;
    private bool invulneravel = false;
    private bool lutaIniciada = false;

    void Start()
    {
        vidaAtual = vidaMax;
        estaminaAtual = estaminaMax;
        AtualizarBarras();
        StartCoroutine(DialogoInicial());
    }

    void Update()
    {
        if (!lutaIniciada) return;
        if (golpeExecutando) return;

        // Ataques só se tiver estamina suficiente
        if (estaminaAtual >= 20f)
        {
            if (Input.GetKeyDown(teclaOiZuki)) StartCoroutine(ExecutarGolpe(parametroOiZuki, danoOiZuki));
            if (Input.GetKeyDown(teclaMaeGeri)) StartCoroutine(ExecutarGolpe(parametroMaeGeri, danoMaeGeri));
            if (Input.GetKeyDown(teclaMawashiGeri)) StartCoroutine(ExecutarGolpe(parametroMawashiGeri, danoMawashiGeri));
        }

        if (Input.GetKeyDown(teclaGedanBarai) && estaminaAtual >= 10f) StartCoroutine(ExecutarDefesa(parametroGedanBarai));
        if (Input.GetKeyDown(teclaJodanUke) && estaminaAtual >= 10f) StartCoroutine(ExecutarDefesa(parametroJodanUke));

        // Recupera estamina quando não atacando
        if (!golpeExecutando && !defendendo)
        {
            estaminaAtual += 15f * Time.deltaTime;
            if (estaminaAtual > estaminaMax) estaminaAtual = estaminaMax;
            AtualizarBarras();
        }
    }

    IEnumerator DialogoInicial()
    {
        if (dialogoSimples != null)
        {
            dialogoSimples.MostrarDialogo("Sensei", spriteSensei, "Você treinou para este momento. Agora, não é sobre vencer ou perder — é sobre mostrar quem você se tornou.");
            yield return new WaitForSeconds(4f);
            dialogoSimples.FecharDialogo();

            yield return new WaitForSeconds(0.5f);
            dialogoSimples.MostrarDialogo("Juiz", spriteJuiz, "Comece!");
            yield return new WaitForSeconds(2f);
            dialogoSimples.FecharDialogo();
        }

        lutaIniciada = true;
        inimigo.lutaIniciada = true;
    }

    IEnumerator ExecutarGolpe(string parametro, float dano)
    {
        golpeExecutando = true;
        estaminaAtual -= 20f;
        AtualizarBarras();

        if (efeitoGolpePrefab != null)
            Instantiate(efeitoGolpePrefab, transform.position + Vector3.right * 1f, Quaternion.identity);

        if (efeitoTrilhaGolpe != null)
        {
            GameObject trilha = Instantiate(efeitoTrilhaGolpe, transform.position + Vector3.right * 1f, Quaternion.identity);
            Destroy(trilha, 0.5f);
        }

        animator.SetBool(parametro, true);
        yield return new WaitForSeconds(0.4f);
        animator.SetBool(parametro, false);

        animator.SetBool(parametroIdle, true);
        yield return new WaitForSeconds(0.05f);
        animator.SetBool(parametroIdle, false);

        if (inimigo != null && Vector3.Distance(transform.position, inimigo.transform.position) <= 2f)
            inimigo.ReceberDano(dano, efeitoImpactoPrefab);

        golpeExecutando = false;
    }

    IEnumerator ExecutarDefesa(string parametro)
    {
        defendendo = true;
        invulneravel = true;
        estaminaAtual -= 10f;
        AtualizarBarras();

        animator.SetBool(parametroDefesa, true);
        animator.SetBool(parametro, true);

        yield return new WaitForSeconds(2f);

        animator.SetBool(parametro, false);
        animator.SetBool(parametroDefesa, false);
        animator.SetBool(parametroIdle, true);
        yield return new WaitForSeconds(0.05f);
        animator.SetBool(parametroIdle, false);

        defendendo = false;
        invulneravel = false;
    }

    public void ReceberDano(float dano, GameObject efeitoImpacto = null)
    {
        if (invulneravel) return;

        vidaAtual -= dano;
        if (vidaAtual < 0) vidaAtual = 0;
        AtualizarBarras();

        if (efeitoImpacto != null)
            Instantiate(efeitoImpacto, transform.position + Vector3.right * 0.5f, Quaternion.identity);

        StartCoroutine(ImpactShake());

        if (vidaAtual <= 0)
        {
            Debug.Log("Player derrotado!");
            SceneManager.LoadScene("CenaDerrota");
        }
    }

    IEnumerator ImpactShake()
    {
        Vector3 posOriginal = transform.position;
        float shakeTempo = 0.2f;
        float shakeForca = 0.1f;
        float timer = 0f;

        while (timer < shakeTempo)
        {
            transform.position = posOriginal + (Vector3)Random.insideUnitCircle * shakeForca;
            timer += Time.deltaTime;
            yield return null;
        }

        transform.position = posOriginal;
    }

    void AtualizarBarras()
    {
        if (barraVida != null) barraVida.value = vidaAtual / vidaMax;
        if (barraEstamina != null) barraEstamina.value = estaminaAtual / estaminaMax;
    }

    // -----------------------------
    // Métodos OnClick para Mobile
    // -----------------------------
    public void BtnOiZuki() => StartCoroutine(ExecutarGolpe(parametroOiZuki, danoOiZuki));
    public void BtnMaeGeri() => StartCoroutine(ExecutarGolpe(parametroMaeGeri, danoMaeGeri));
    public void BtnMawashiGeri() => StartCoroutine(ExecutarGolpe(parametroMawashiGeri, danoMawashiGeri));
    public void BtnGedanBarai() => StartCoroutine(ExecutarDefesa(parametroGedanBarai));
    public void BtnJodanUke() => StartCoroutine(ExecutarDefesa(parametroJodanUke));
}

          </code></pre>
          <div class="codigo-resumo">
            <h3>Resumo:</h3>
            <p>Gerencia o personagem principal, permitindo executar golpes e defesas com consumo de estamina, interagir com o inimigo, exibir diálogos iniciais e controlar as barras de vida e energia durante a luta.</p>
          </div>
        </div>

        <div id="codigo3" class="codigo-bloco">
          <pre><code class="language-csharp">
using UnityEngine;
using System.Collections;

public class AlvoBalanco : MonoBehaviour
{
  public float velocidade = 5f; 
    private Quaternion rotacaoInicial;

    void Start()
    {
        rotacaoInicial = transform.localRotation;
    }

    public void Balancar(float angulo)
    {
        StopAllCoroutines();
        StartCoroutine(BalancarRoutine(angulo));
    }
    public void BalancarComEixo(float anguloX, float anguloY, float anguloZ)
{
    StopAllCoroutines();
    StartCoroutine(BalancarRoutineEixo(anguloX, anguloY, anguloZ));
}

IEnumerator BalancarRoutineEixo(float anguloX, float anguloY, float anguloZ)
{
    Quaternion rotacaoInicial = transform.localRotation;
    Quaternion rotacaoFinal = Quaternion.Euler(anguloX, anguloY, anguloZ) * rotacaoInicial;

    float t = 0;
    while (t < 1)
    {
        t += Time.deltaTime * velocidade;
        transform.localRotation = Quaternion.Slerp(rotacaoInicial, rotacaoFinal, t);
        yield return null;
    }

    t = 0;
    while (t < 1)
    {
        t += Time.deltaTime * velocidade;
        transform.localRotation = Quaternion.Slerp(rotacaoFinal, rotacaoInicial, t);
        yield return null;
    }
}


    IEnumerator BalancarRoutine(float angulo)
    {
        Quaternion rotacaoFrente = Quaternion.Euler(angulo, 0, 0) * rotacaoInicial;
        float t = 0;
        while (t < 1)
        {
            t += Time.deltaTime * velocidade;
            transform.localRotation = Quaternion.Slerp(rotacaoInicial, rotacaoFrente, t);
            yield return null;
        }

        t = 0;
        while (t < 1)
        {
            t += Time.deltaTime * velocidade;
            transform.localRotation = Quaternion.Slerp(rotacaoFrente, rotacaoInicial, t);
            yield return null;
        }
    }
}
          </code></pre>
          <div class="codigo-resumo">
            <h3>Resumo:</h3>
            <p>Cria um efeito de balanço suave em objetos, oscilando sua rotação entre dois ângulos. Ideal para dar movimento a alvos ou elementos interativos da cena.</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <footer class="site-footer">
    <p>© 2025 <strong>ByteCompilers</strong> — Projeto <em>Martial Spirit</em></p>
    <p>Desenvolvido por Maria Espigiorin</p>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
    const tabs = document.querySelectorAll('.tab');
    const blocos = document.querySelectorAll('.codigo-bloco');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        const alvo = tab.getAttribute('data-tab');
        blocos.forEach(b => b.classList.remove('active'));
        document.getElementById(alvo).classList.add('active');
      });
    });
  </script>
</body>

</html>